import argparse
import pandas as pd
import os
from pathlib import Path
import numpy as np
import h5py


def read_hdf5(file_path):
    f = h5py.File(file_path, 'r')
    img = list(f['data'])
    return np.stack(img,axis=0)

def image_generator(summary, home_path,batch_size = 64,random_crop_img = False,crop_size = (960,960)):
    indexs = summary.index.tolist()
    while True:
        # Select files (paths/indices) for the batch
        batch_input = []
        batch_output = []

        # Read in each input, perform preprocessing and get labels
        load_img = 0
        try:
            while load_img < batch_size:
                row = np.random.choice(indexs,size=1)
                row = summary.loc[row]
                file_name = row['File Name'].values[0]
                month = row['Month'].values[0]
                label = int(row['KLG'])
                file_path = os.path.join(home_path,month,file_name)
                img = read_hdf5(file_path)
                # filter invalid image
                if img.shape[0] == 1024 and img.shape[1] == 1024:
                    if random_crop_img:  # random crop if necessary
                        img = random_crop(img, crop_size)
                    batch_input.append(img)
                    batch_output.append(label)
                    load_img += 1
            # Return a tuple of (input,output) to feed the network
            num_classes = 5 # KL grade 0 - 4
            batch_x = np.stack(batch_input,axis = 0)
            batch_x = np.expand_dims(batch_x,axis = -1)
            batch_y = np.array(np.stack(batch_output,axis = 0),dtype=np.int)
            batch_y_one_hot = np.zeros((batch_size,num_classes))
            batch_y_one_hot[np.arange(batch_size),batch_y] = 1
        except ValueError:
            print(row)
            raise ValueError('############ Wrong input image #########')
        yield( batch_x, batch_y_one_hot )

def image_generator_eval(summary, model,home_path,batch_size = 8,random_crop_img = False,crop_size = (960,960)):
    '''
    This function is used to evaluate all samples in the summary
    :param summary:
    :param model:
    :param home_path:
    :param batch_size:
    :param random_crop_img: bool True, enable random crop for each instance
    :param crop_size: tuple (x dimension, y dimension)
    :return:
    '''
    indexs = summary.index.tolist()

    load_img = 0
    n_correct = 0
    while load_img < len(indexs) - batch_size:
        batch_input = []
        batch_output = []
        for idx in indexs[load_img:load_img + batch_size]:
            row = summary.loc[idx]
            file_name = row['File Name']
            month = row['Month']
            label = int(row['KLG'])
            file_path = os.path.join(home_path, month, file_name)
            img = read_hdf5(file_path)
            # filter invalid image
            if img.shape[0] == 1024 and img.shape[1] == 1024:
                if random_crop_img: # random crop if necessary
                    img = random_crop(img,crop_size)
                batch_input.append(img)
                batch_output.append(label)
            # Return a tuple of (input,output) to feed the network
        num_classes = 5  # KL grade 0 - 4
        batch_x = np.stack(batch_input, axis=0)
        batch_x = np.expand_dims(batch_x, axis=-1)
        batch_y = np.array(np.stack(batch_output, axis=0), dtype=np.int)
        batch_y_one_hot = np.zeros((batch_size, num_classes))
        batch_y_one_hot[np.arange(batch_size), batch_y] = 1
        print('Evaluation:')
        test_loss, test_acc = model.evaluate(batch_x,batch_y_one_hot)
        n_correct += test_acc * batch_size
        load_img += batch_size
        print('This batch loss {}, acc {}, overall {}'.format(test_loss,test_acc,n_correct / load_img))

    return n_correct,load_img - batch_size

'''
This part of code is taken from Kelvin's from_scratch_cross_validation_functions_randCrop.py
'''
def random_crop(img, random_crop_size):
    '''
    Take an image as input and random crop to given size
    :param img: it should be 1024 x 1024 x 1 based on preprocessing
    :param random_crop_size: 960 x 960 x 1
    :return:
    '''
    # Note: image_data_format is 'channel_last'
    #assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    x = np.random.randint(0, width - dx + 1)
    y = np.random.randint(0, height - dy + 1)
    return img[y:(y+dy), x:(x+dx)] # for each instance of XRAY only two dimensions in img data.


def crop_generator(batches, crop_length):
    '''
    Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator
    '''
    while True:
        batch_x, batch_y = next(batches)
        batch_crops = np.zeros((batch_x.shape[0], crop_length, crop_length, 1))
        for i in range(batch_x.shape[0]):
            batch_crops[i] = random_crop(batch_x[i], (crop_length, crop_length))
        yield (batch_crops, batch_y)